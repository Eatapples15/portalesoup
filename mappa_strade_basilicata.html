<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Mappa con Tracciato Dettagliato</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        html, body, #map { height: 100%; width: 100%; margin: 0; padding: 0; }
        .leaflet-popup-content { font-family: sans-serif; font-size: 12px; }
        .loading-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.8);
            padding: 20px;
            border-radius: 5px;
            font-family: sans-serif;
            font-size: 16px;
            z-index: 1000;
        }
    </style>
</head>
<body>

<div id="map"></div>
<div id="loading" class="loading-message">Caricamento tracciato dettagliato...</div>

<script>
    // 1. Inizializzazione Mappa
    const map = L.map('map').setView([40.5, 16.2], 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Funzioni ausiliarie (invariate)
    function getDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3;
        const φ1 = lat1 * Math.PI / 180, φ2 = lat2 * Math.PI / 180;
        const Δλ = (lon2 - lon1) * Math.PI / 180;
        const d = Math.acos(Math.sin(φ1) * Math.sin(φ2) + Math.cos(φ1) * Math.cos(φ2) * Math.cos(Δλ)) * R;
        return d;
    }

    function generateKilometerMarkers(polyline, layerGroup) {
        let totalDistance = 0, lastMarkerDistance = 0;
        const latlngs = polyline.getLatLngs();
        for (let i = 0; i < latlngs.length - 1; i++) {
            const startPoint = latlngs[i], endPoint = latlngs[i + 1];
            const segmentDistance = getDistance(startPoint.lat, startPoint.lng, endPoint.lat, endPoint.lng);
            while (lastMarkerDistance + 1000 <= totalDistance + segmentDistance) {
                const distanceToNextMarker = lastMarkerDistance + 1000 - totalDistance;
                const ratio = distanceToNextMarker / segmentDistance;
                const markerLat = startPoint.lat + (endPoint.lat - startPoint.lat) * ratio;
                const markerLng = startPoint.lng + (endPoint.lng - startPoint.lng) * ratio;
                const km = Math.round((lastMarkerDistance + 1000) / 1000);
                const marker = L.circleMarker([markerLat, markerLng], { radius: 4, color: '#c0392b', fillColor: '#e74c3c', fillOpacity: 1 });
                marker.bindPopup(`<b>SS407 - Km: ${km}</b><br>Lat: ${markerLat.toFixed(6)}<br>Lon: ${markerLng.toFixed(6)}`);
                marker.addTo(layerGroup);
                lastMarkerDistance += 1000;
            }
            totalDistance += segmentDistance;
        }
    }

    // 2. Funzione per recuperare e disegnare il tracciato
    async function fetchAndDrawRoute(startCoords, endCoords, roadInfo) {
        const loadingMessage = document.getElementById('loading');
        loadingMessage.style.display = 'block';

        // Costruisce l'URL per l'API di routing
        const url = `https://router.project-osrm.org/route/v1/driving/${startCoords.lng},${startCoords.lat};${endCoords.lng},${endCoords.lat}?overview=full&geometries=geojson`;

        try {
            const response = await fetch(url);
            const data = await response.json();
            
            if (data.code !== 'Ok') {
                throw new Error('Impossibile trovare un percorso.');
            }
            
            // Estrae la geometria del percorso (una lista di coordinate)
            const routeCoordinates = data.routes[0].geometry.coordinates.map(coord => [coord[1], coord[0]]); // Inverte [lon, lat] a [lat, lon]
            
            // Crea il tracciato e il gruppo di layer
            const polyline = L.polyline(routeCoordinates, { color: roadInfo.color, weight: 6 });
            const roadLayerGroup = L.layerGroup();
            
            polyline.addTo(roadLayerGroup);
            generateKilometerMarkers(polyline, roadLayerGroup);
            
            // Aggiunge il layer alla mappa e al controllo
            roadLayerGroup.addTo(map);
            layerControl.addOverlay(roadLayerGroup, roadInfo.label);

            // Centra la mappa sul tracciato
            map.fitBounds(polyline.getBounds());

        } catch (error) {
            console.error('Errore nel caricamento del tracciato:', error);
            alert(`Non è stato possibile caricare il tracciato per ${roadInfo.label}.`);
        } finally {
            loadingMessage.style.display = 'none';
        }
    }

    // 3. Esecuzione
    const layerControl = L.control.layers(null, null, { collapsed: false }).addTo(map);

    // Definiamo i punti di inizio e fine per la SS407 "Basentana"
    const ss407_start = { lat: 40.638, lng: 15.755 }; // Potenza Est
    const ss407_end = { lat: 40.380, lng: 16.822 };   // Metaponto
    const ss407_info = { label: 'SS407 Basentana (Dettagliata)', color: '#e74c3c' };

    // Chiamiamo la funzione per disegnare la strada
    fetchAndDrawRoute(ss407_start, ss407_end, ss407_info);

</script>
</body>
</html>
